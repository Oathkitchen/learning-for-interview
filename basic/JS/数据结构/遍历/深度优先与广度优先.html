<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DFS vs BFS 可视化演示</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      background-color: #f0f2f5;
    }
    
    h1 {
      color: #333;
    }

    .controls {
      margin: 20px;
      position: sticky;
      top: 20px;
      z-index: 100;
      background: rgba(255,255,255,0.9);
      padding: 10px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }

    button {
      padding: 10px 20px;
      margin: 0 10px;
      cursor: pointer;
      border: none;
      border-radius: 4px;
      background-color: #1890ff;
      color: white;
      font-size: 16px;
      transition: background-color 0.3s;
    }

    button:hover {
      background-color: #40a9ff;
    }

    button.reset {
      background-color: #ff4d4f;
    }
    
    button.reset:hover {
      background-color: #ff7875;
    }
    
    /* Tree Styling */
    .node {
      border: 2px solid #8c8c8c;
      padding: 10px;
      margin: 10px;
      border-radius: 8px;
      background-color: #fff;
      transition: all 0.3s;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-width: 60px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.05);
    }
    
    .children {
      display: flex;
      justify-content: center;
      margin-top: 10px;
      gap: 10px;
    }

    /* 正在访问的节点 */
    .active {
      background-color: #1890ff !important; 
      color: white;
      border-color: #096dd9;
      transform: scale(1.1);
      box-shadow: 0 0 15px rgba(24, 144, 255, 0.5);
    }
    
    /* 已访问过的节点 */
    .visited {
      background-color: #52c41a;
      color: white;
      border-color: #389e0d;
    }

    /* 代码展示区样式 */
    .code-section {
      display: flex;
      gap: 20px;
      margin-top: 30px;
      width: 90%;
      max-width: 1000px;
      margin-bottom: 40px;
    }
    
    .code-block {
      flex: 1;
      background: #282c34;
      border-radius: 8px;
      padding: 15px;
      color: #abb2bf;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
      overflow-x: auto;
    }

    .code-block h3 {
      color: #61dafb;
      margin-top: 0;
      border-bottom: 1px solid #3e4451;
      padding-bottom: 10px;
      margin-bottom: 10px;
    }

    pre {
      margin: 0;
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
      font-size: 14px;
      line-height: 1.5;
    }
  </style>
</head>
<body>

  <h1>深度优先 (DFS) vs 广度优先 (BFS)</h1>

  <div class="controls">
    <button onclick="startDFS()">深度优先遍历 (DFS)</button>
    <button onclick="startBFS()">广度优先遍历 (BFS)</button>
    <button class="reset" onclick="reset()">重置</button>
  </div>

  <!-- DOM 树结构 -->
  <div id="root" class="node">
    Root
    <div class="children">
      <div class="node">
        A
        <div class="children">
          <div class="node">A-1</div>
          <div class="node">A-2</div>
        </div>
      </div>
      <div class="node">
        B
        <div class="children">
          <div class="node">
            B-1
            <div class="children">
                <div class="node">B-1-1</div>
            </div>
          </div>
          <div class="node">B-2</div>
        </div>
      </div>
      <div class="node">C</div>
    </div>
  </div>

  <!-- 代码展示区 -->
  <div class="code-section">
    <div class="code-block">
      <h3>DFS (递归实现)</h3>
      <pre>
// 深度优先遍历
async function dfs(node) {
  if (!node) return;
  
  // 1. 访问当前节点
  await highlight(node);

  // 2. 递归访问子节点
  const children = getChildNodes(node);
  for (let child of children) {
    await dfs(child);
  }
}
      </pre>
    </div>
    <div class="code-block">
      <h3>BFS (队列实现)</h3>
      <pre>
// 广度优先遍历
async function bfs(root) {
  const queue = [root];
  
  while (queue.length > 0) {
    // 1. 取出队头
    const node = queue.shift();
    
    // 2. 访问节点
    await highlight(node);

    // 3. 将子节点加入队尾
    const children = getChildNodes(node);
    children.forEach(child => queue.push(child));
  }
}
      </pre>
    </div>
  </div>

  <script>
    const root = document.getElementById('root');
    const delayTime = 800; // 动画延迟时间 ms
    let isRunning = false;

    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    function reset() {
      // 如果正在运行，可以通过刷新页面强制停止，或者这里简单重置样式
      // 实际生产中应该有一个 abort controller 或者 flag
      if (isRunning) {
        window.location.reload();
        return;
      }
      
      const nodes = document.querySelectorAll('.node');
      nodes.forEach(node => {
        node.classList.remove('active');
        node.classList.remove('visited');
      });
    }

    async function highlight(node) {
      node.classList.add('active');
      await sleep(delayTime);
      node.classList.remove('active');
      node.classList.add('visited');
      await sleep(200); // 短暂停顿，让视觉过渡更自然
    }

    // 获取子节点元素 (过滤掉非 .node 元素)
    function getChildNodes(node) {
      const childrenContainer = node.querySelector('.children');
      if (!childrenContainer) return [];
      return Array.from(childrenContainer.children).filter(el => el.classList.contains('node'));
    }

    // DFS: Depth First Search (深度优先)
    async function startDFS() {
      if (isRunning) return;
      reset();
      isRunning = true;
      await dfs(root);
      isRunning = false;
    }

    async function dfs(node) {
      if (!node) return;
      
      // 1. 访问当前节点
      await highlight(node);

      // 2. 递归访问子节点
      const children = getChildNodes(node);
      for (let child of children) {
        await dfs(child);
      }
    }

    // BFS: Breadth First Search (广度优先)
    async function startBFS() {
      if (isRunning) return;
      reset();
      isRunning = true;
      
      const queue = [root];
      
      while (queue.length > 0) {
        // 1. 取出队头
        const node = queue.shift();
        
        // 2. 访问节点
        await highlight(node);

        // 3. 将子节点加入队尾
        const children = getChildNodes(node);
        children.forEach(child => queue.push(child));
      }
      
      isRunning = false;
    }
  </script>
</body>
</html>