<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      // åœ¨ js ä¸­å¦‚ä½•æŠŠç±»æ•°ç»„è½¬åŒ–ä¸ºæ•°ç»„
      // ä¸€ä¸ªç®€å•çš„å®šä¹‰ï¼Œå¦‚æžœä¸€ä¸ªå¯¹è±¡æœ‰ length å±žæ€§å€¼ï¼Œåˆ™å®ƒå°±æ˜¯ç±»æ•°ç»„
      // [undefined, undefined, undefined]
      console.log(Array.from({ length: 3 }));
      const arrayLike = {
        0: 3,
        1: 4,
        2: 5,
        length: 3,
      };
      console.log(Array.prototype.slice.call(arrayLike));
      // æŠŠç±»æ•°ç»„è½¬åŒ–æˆæ•°ç»„æœ€é è°±çš„æ–¹å¼æ˜¯ä»¥ä¸‹ä¸‰ä¸ª
      Array.from(arrayLike);
      Array.apply(null, arrayLike);
      Array.prototype.concat.apply([], arrayLike);

      // ä»¥ä¸‹å‡ ç§æ–¹å¼éœ€è¦è€ƒè™‘ç¨€ç–æ•°ç»„çš„è½¬åŒ–
      // Array.prototype.filter.call(divs, (x) => 1);
      Array.prototype.map.call(arrayLike, (x) => x);
      Array.prototype.filter.call(arrayLike, (x) => 1);

      // ä»¥ä¸‹æ–¹æ³•è¦æ³¨æ„æ˜¯å¦æ˜¯ iterable object
      // [...arrayLike];

      // æ³¨æ„ä¸‹é¢çš„ç»“æžœæ˜¯ï¼š[0, 1, 2, 1, 2, 3]ï¼Œæ˜¯å› ä¸ºç”¨äº† Funtion.prototype.apply() æ–¹æ³•
      // https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply
      console.log(
        Array.prototype.concat.apply([], {
          0: 0,
          1: 1,
          2: 2,
          3: [1, 2, 3],
          length: 4,
        })
      );

      const num1 = [[1]];
      const num2 = [2, [3]];
      const numbers = num1.concat(num2);
      console.log(numbers);

      // js ä¸­ä»€ä¹ˆæ˜¯å¯é€‰é“¾æ“ä½œç¬¦ï¼Œå¦‚ä½•è®¿é—®æ•°ç»„
      const obj = { a: [1, 2], b() {} };
      // è®¿é—®æ•°ç»„
      obj?.a?.[0];
      //ä½¿ç”¨æ–¹æ³•
      obj?.b?.();

      // æ‰‹åŠ¨å®žçŽ° Promise.allSettled

      function allSettled(promises = []) {
        return new Promise((resolve) => {
          let count = 0;
          let values = new Array(promises.length);
          const collect = (index, status) => (value) => {
            const prop = status === "fulfilled" ? "value" : "reason";
            values[index] = { status, [prop]: value };
            ++count === promises.length && resolve(values);
          };
          promises.forEach((promise, i) => {
            if (isPromise(promise)) {
              promise.then(collect(i, "fulfilled"), collect(i, "rejected"));
            } else {
              collect(i, "fulfilled")(promise);
            }
          });
        });
      }

      function isPromise(promise) {
        return promise && typeof promise.then === "function";
      }

      // my own Symbol.iterator
      let range = {
        from: 1,
        to: 5,
      };

      // 1. call to for..of initially calls this
      range[Symbol.iterator] = function () {
        // ...it returns the iterator object:
        // 2. Onward, for..of works only with the iterator object below, asking it for next values
        return {
          current: this.from,
          last: this.to,

          // 3. next() is called on each iteration by the for..of loop
          next() {
            // 4. it should return the value as an object {done:.., value :...}
            if (this.current <= this.last) {
              return { done: false, value: this.current++ };
            } else {
              return { done: true };
            }
          },
        };
      };

      // now it works!
      for (let num of range) {
        alert(num); // 1, then 2, 3, 4, 5
      }

      // another example
      // The downside is that now itâ€™s impossible to have two for..of loops running over the object simultaneously:
      // theyâ€™ll share the iteration state, because thereâ€™s only one iterator â€“ the object itself.
      // But two parallel for-ofs is a rare thing, even in async scenarios.
      let range = {
        from: 1,
        to: 5,

        [Symbol.iterator]() {
          this.current = this.from;
          return this;
        },

        next() {
          if (this.current <= this.to) {
            return { done: false, value: this.current++ };
          } else {
            return { done: true };
          }
        },
      };

      for (let num of range) {
        alert(num); // 1, then 2, 3, 4, 5
      }

      // Iterables are objects that implement the Symbol.iterator method, as described above.
      // Array-likes are objects that have indexes and length, so they look like arrays.
      // Thereâ€™s a universal method Array.from that takes an iterable or array-like value and makes a â€œrealâ€ Array from it.
      // Then we can call array methods on it.
      // Unlike str.split, it relies on the iterable nature of the string and so, just like for..of, correctly works with surrogate pairs.

      let str = "ð’³ðŸ˜‚";

      // splits str into array of characters
      let chars = Array.from(str);

      alert(chars[0]); // ð’³
      alert(chars[1]); // ðŸ˜‚
      alert(chars.length); // 2

      // We can even build surrogate-aware slice on it:
      function slice(str, start, end) {
        return Array.from(str).slice(start, end).join("");
      }

      let str = "ð’³ðŸ˜‚ð©·¶";

      alert(slice(str, 1, 3)); // ðŸ˜‚ð©·¶

      // the native method does not support surrogate pairs
      alert(str.slice(1, 3)); // garbage (two pieces from different surrogate pairs)

      // JS å¦‚ä½•æ£€æµ‹åˆ°å¯¹è±¡ä¸­æœ‰å¾ªçŽ¯å¼•ç”¨
      function hasCircularReference(obj) {
        const seen = new WeakMap(); // ç”¨ WeakMap è®°å½•å·²è®¿é—®çš„å¯¹è±¡ï¼ˆé¿å…å†…å­˜æ³„æ¼ï¼‰

        function detect(obj) {
          // éžå¯¹è±¡æˆ– null ç›´æŽ¥è¿”å›ž
          if (obj === null || typeof obj !== "object") return false;

          // è‹¥å¯¹è±¡å·²è®°å½•è¿‡ï¼Œè¯´æ˜Žå­˜åœ¨å¾ªçŽ¯å¼•ç”¨
          if (seen.has(obj)) return true;

          // æ ‡è®°å½“å‰å¯¹è±¡ä¸ºå·²è®¿é—®
          seen.set(obj, true);

          // é€’å½’æ£€æŸ¥æ‰€æœ‰å±žæ€§å€¼
          for (const key of Object.keys(obj)) {
            const value = obj[key];
            if (detect(value)) return true; // å‘çŽ°å¾ªçŽ¯
          }

          return false;
        }

        return detect(obj);
      }
      // ç¤ºä¾‹ 1ï¼šæ— å¾ªçŽ¯å¼•ç”¨
      const obj1 = { a: 1, b: { c: 2 } };
      console.log(hasCircularReference(obj1)); // false

      // ç¤ºä¾‹ 2ï¼šç›´æŽ¥å¾ªçŽ¯å¼•ç”¨
      const obj2 = {};
      obj2.self = obj2;
      console.log(hasCircularReference(obj2)); // true

      // ç¤ºä¾‹ 3ï¼šé—´æŽ¥å¾ªçŽ¯å¼•ç”¨
      const obj3 = { x: {} };
      obj3.x.y = obj3;
      console.log(hasCircularReference(obj3)); // true

      // ç¤ºä¾‹ 4ï¼šæ•°ç»„å¾ªçŽ¯å¼•ç”¨
      const arr = [];
      arr.push(arr);
      console.log(hasCircularReference(arr)); // true

      // JS æ·±å…‹éš†æ—¶å¦‚ä½•å¤„ç†å¾ªçŽ¯å¼•ç”¨
      function deepClone(obj, hash = new WeakMap()) {
        // å¤„ç†åŸºæœ¬ç±»åž‹å’Œ null/undefined
        if (obj === null || typeof obj !== "object") {
          return obj;
        }

        // å¤„ç†å¾ªçŽ¯å¼•ç”¨ï¼šè‹¥å·²å…‹éš†è¿‡ï¼Œç›´æŽ¥è¿”å›žå…‹éš†å‰¯æœ¬
        if (hash.has(obj)) {
          return hash.get(obj);
        }

        // å¤„ç†ç‰¹æ®Šå¯¹è±¡ç±»åž‹
        let clone;
        if (obj instanceof Date) {
          clone = new Date(obj);
        } else if (obj instanceof RegExp) {
          clone = new RegExp(obj);
        } else if (obj instanceof Map) {
          clone = new Map([...obj]);
        } else if (obj instanceof Set) {
          clone = new Set([...obj]);
        } else if (Array.isArray(obj)) {
          clone = [];
        } else {
          clone = Object.create(Object.getPrototypeOf(obj));
        }

        // è®°å½•å½“å‰å¯¹è±¡å’Œå…‹éš†å¯¹è±¡çš„æ˜ å°„å…³ç³»
        hash.set(obj, clone);

        // é€’å½’å…‹éš†æ‰€æœ‰å±žæ€§
        for (const key of Reflect.ownKeys(obj)) {
          // åŒ…å« Symbol å±žæ€§
          const value = obj[key];
          clone[key] = deepClone(value, hash);
        }

        return clone;
      }

      // åˆ›å»ºå¾ªçŽ¯å¼•ç”¨å¯¹è±¡
      const original = { name: "Original" };
      original.self = original; // ç›´æŽ¥å¾ªçŽ¯å¼•ç”¨
      original.child = { parent: original }; // é—´æŽ¥å¾ªçŽ¯å¼•ç”¨

      // æ·±å…‹éš†
      const cloned = deepClone(original);

      console.log(cloned !== original); // trueï¼ˆå…‹éš†æˆåŠŸï¼‰
      console.log(cloned.self === cloned); // trueï¼ˆå¾ªçŽ¯å¼•ç”¨è¢«æ­£ç¡®å…‹éš†ï¼‰
      console.log(cloned.child.parent === cloned); // trueï¼ˆé—´æŽ¥å¼•ç”¨æ­£ç¡®ï¼‰
    </script>
  </body>
</html>
