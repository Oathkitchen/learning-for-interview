**gzip 的核心原理**结合了 **LZ77 算法**和 **Huffman 编码**，分两阶段压缩数据：  
1. **LZ77** 消除重复字符串（冗余信息）；  
2. **Huffman 编码** 根据符号频率进一步压缩。  
以下详细分步解析：

---

### **一、LZ77 算法：基于滑动窗口的重复替换**
**核心思想**：用**指针（距离，长度）**替换重复出现的字符串。

#### 1. **滑动窗口结构**
- **查找缓冲区（Search Buffer）**：已处理的数据（滑动窗口的左侧），用于寻找重复模式。
- **前向缓冲区（Look-ahead Buffer）**：待处理的数据（滑动窗口右侧），需匹配最长重复串。

例如，滑动窗口大小为 10，当前处理位置为：  
`[已处理部分: "ABCDE..."] [待处理部分: "ABCEF..."]`  
LZ77 会在左侧查找与右侧开头的最大匹配。

#### 2. **三元组表示重复串**
当找到最长匹配时，输出一个**三元组 `(距离, 长度, 下一个字符)`**：  
- **距离**：从当前位置回溯到匹配起点的偏移量。  
- **长度**：匹配的字符数。  
- **下一个字符**：匹配后的第一个不匹配字符（解决无匹配的情况）。

**示例**：  
字符串 `"ABCEABCED..."`，当前处理到第二个 `"ABCE"`：  
- 匹配到左侧的 `"ABCE"`，距离为 4，长度为 4，下一字符是 `'D'`。  
- 输出三元组 `(4, 4, D)`，压缩为更短的表示。

#### 3. **滑动窗口的移动**
窗口向前滑动 `长度 + 1` 的位置（跳过了已压缩部分）。

---

### **二、Huffman 编码：基于频率的变长编码**
**核心思想**：高频符号用短编码，低频符号用长编码，减少总比特数。

#### 1. **构建 Huffman 树**
- 统计符号频率，生成优先级队列（频率低的优先合并）。  
- 反复合并频率最低的两个节点，生成二叉树，直到只剩根节点。

**示例**：符号 `A(50%)`, `B(25%)`, `C(25%)`：  
- 合并 `B` 和 `C` → 新节点 `BC(50%)`。  
- 合并 `A` 和 `BC` → 根节点。  
- 编码结果：`A→0`, `B→10`, `C→11`。

#### 2. **前缀无歧义性**
Huffman 编码是**前缀码**，任何编码都不是其他编码的前缀，确保解码唯一性。

---

### **三、gzip 的协作流程**
1. **LZ77 处理**：将原始数据转换为一系列 **literal（未匹配字符）** 和 **三元组（距离、长度）**。  
2. **Huffman 编码**：对 LZ77 的输出分块进行编码：  
   - **动态 Huffman 树**：为每个数据块生成定制编码表（适应数据特征）。  
   - **双 Huffman 树**：DEFLATE 格式（gzip 的基础）使用两棵树：  
     - **Literal/Length 树**：压缩字符和匹配长度。  
     - **Distance 树**：压缩匹配距离。  

**优势互补**：  
- LZ77 消除重复结构，生成更符号化的数据（适合 Huffman 压缩）。  
- Huffman 编码进一步缩短高频符号的表示。

---

### **四、总结**
- **LZ77**：通过滑动窗口和指针替换冗余，输出符号流。  
- **Huffman**：通过统计优化编码长度，最大化压缩率。  
- **协同效果**：LZ77 处理局部重复，Huffman 处理全局统计特征，二者结合显著提升压缩效率。