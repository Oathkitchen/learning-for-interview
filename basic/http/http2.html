<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTTP/2 多路复用演示</title>
    <style>
        :root {
            --primary-color: #4361ee;
            --secondary-color: #3f37c9;
            --accent-color: #4895ef;
            --success-color: #4cc9f0;
            --warning-color: #f72585;
            --bg-color: #f8f9fa;
            --card-bg: #ffffff;
            --text-main: #2b2d42;
            --text-light: #8d99ae;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            max-width: 1100px;
            margin: 0 auto;
            padding: 40px 20px;
            background-color: var(--bg-color);
            color: var(--text-main);
            line-height: 1.6;
        }

        h1 { 
            text-align: center; 
            color: var(--text-main);
            font-weight: 800;
            margin-bottom: 40px;
            font-size: 2.5rem;
            background: linear-gradient(135deg, var(--primary-color), var(--warning-color));
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        h2 { 
            color: var(--secondary-color); 
            border-bottom: 2px solid #edf2f4; 
            padding-bottom: 15px; 
            margin-top: 0;
            font-weight: 600;
        }
        
        h3 {
            color: var(--text-main);
            font-weight: 600;
        }

        .section {
            background: var(--card-bg);
            padding: 30px;
            margin-bottom: 30px;
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.05);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .section:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 35px rgba(0,0,0,0.1);
        }

        .concept-box {
            display: flex;
            gap: 40px;
            flex-wrap: wrap;
        }
        
        .concept {
            flex: 1;
            min-width: 300px;
            background: #f8f9fa;
            padding: 20px;
            border-radius: 12px;
            border-left: 4px solid var(--primary-color);
        }

        .concept:last-child {
            border-left-color: var(--warning-color);
        }

        code {
            background: #edf2f4;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Fira Code', monospace;
            color: var(--warning-color);
            font-size: 0.9em;
        }

        /* 演示区域样式 */
        .demo-area {
            display: flex;
            gap: 30px;
            margin-top: 30px;
        }

        .protocol-demo {
            flex: 1;
            background: #ffffff;
            padding: 20px;
            border-radius: 16px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
            border: 1px solid rgba(0,0,0,0.05);
        }

        .protocol-title {
            font-weight: 700;
            text-align: center;
            margin-bottom: 20px;
            font-size: 1.3em;
            color: var(--text-main);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .protocol-title::before {
            content: '';
            display: block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        .protocol-demo:first-child .protocol-title::before { background: var(--primary-color); }
        .protocol-demo:last-child .protocol-title::before { background: var(--warning-color); }

        .connection-pool {
            display: flex;
            flex-direction: column;
            gap: 8px;
            height: 450px;
            overflow-y: auto;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 12px;
            border: 1px solid #edf2f4;
            /* 自定义滚动条 */
            scrollbar-width: thin;
            scrollbar-color: #cbd5e1 #f8f9fa;
        }

        .connection-pool::-webkit-scrollbar {
            width: 6px;
        }
        .connection-pool::-webkit-scrollbar-track {
            background: #f8f9fa;
        }
        .connection-pool::-webkit-scrollbar-thumb {
            background-color: #cbd5e1;
            border-radius: 10px;
        }

        .request-item {
            height: 28px;
            background: #e9ecef;
            border-radius: 14px;
            position: relative;
            overflow: hidden;
            font-size: 12px;
            line-height: 28px;
            text-align: center;
            color: #666;
            font-weight: 600;
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.05);
        }

        .progress-bar {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            background: linear-gradient(90deg, var(--success-color), var(--primary-color));
            width: 0%;
            transition: width 0.1s linear;
            border-radius: 14px;
        }
        
        .waiting .progress-bar { 
            background: #ffd60a; 
            opacity: 0.5;
        } 
        
        .finished .progress-bar { 
            background: linear-gradient(90deg, var(--primary-color), var(--secondary-color)); 
        }

        /* 增加条纹动画 */
        .running .progress-bar {
            background-image: linear-gradient(
                45deg, 
                rgba(255, 255, 255, 0.15) 25%, 
                transparent 25%, 
                transparent 50%, 
                rgba(255, 255, 255, 0.15) 50%, 
                rgba(255, 255, 255, 0.15) 75%, 
                transparent 75%, 
                transparent
            );
            background-size: 1rem 1rem;
            animation: progress-stripes 1s linear infinite;
        }

        @keyframes progress-stripes {
            from { background-position: 1rem 0; }
            to { background-position: 0 0; }
        }

        .controls {
            text-align: center;
            margin: 30px 0;
        }

        button {
            padding: 12px 30px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            border: none;
            border-radius: 50px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(67, 97, 238, 0.3);
        }
        
        button:hover { 
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(67, 97, 238, 0.4);
        }
        
        button:active {
            transform: translateY(1px);
        }

        button:disabled { 
            background: #cbd5e1; 
            cursor: not-allowed; 
            box-shadow: none;
            transform: none;
        }

        .legend {
            display: flex;
            justify-content: center;
            gap: 25px;
            margin-bottom: 20px;
            font-size: 14px;
            color: var(--text-light);
            font-weight: 500;
        }
        
        .legend-item { display: flex; align-items: center; gap: 8px; }
        .dot { width: 12px; height: 12px; border-radius: 50%; }
    </style>
</head>
<body>

    <h1>HTTP/2 多路复用 (Multiplexing) 原理与演示</h1>

    <div class="section">
        <h2>1. 核心概念</h2>
        <div class="concept-box">
            <div class="concept">
                <h3>HTTP/1.1 的问题：队头阻塞</h3>
                <p>在 HTTP/1.1 中，浏览器对同一个域名下的 TCP 连接数有限制（通常为 6 个）。</p>
                <p>如果页面有 100 个资源需要加载：</p>
                <ul>
                    <li>浏览器只能同时处理 6 个请求。</li>
                    <li>后续请求必须排队等待前面的请求完成（Keep-Alive 复用连接）。</li>
                    <li>如果某个请求处理很慢，后面的请求就会被阻塞，这就是<strong>队头阻塞 (Head-of-Line Blocking)</strong>。</li>
                </ul>
            </div>
            <div class="concept">
                <h3>HTTP/2 的解决：多路复用</h3>
                <p>HTTP/2 引入了<strong>二进制分帧层</strong>，不再以文本方式传输。</p>
                <ul>
                    <li><strong>单连接</strong>：同域名下所有通信都在单个 TCP 连接上完成。</li>
                    <li><strong>Stream (流)</strong>：每个请求/响应对应一个流，有唯一 ID。</li>
                    <li><strong>Frame (帧)</strong>：数据被拆分成多个帧，乱序发送，接收端根据 ID 重组。</li>
                    <li><strong>无阻塞</strong>：请求可以同时发送，不需要等待上一个请求结束。</li>
                </ul>
            </div>
        </div>
    </div>

    <div class="section">
        <h2>2. 可视化模拟</h2>
        <p>下方模拟加载 30 个资源的情况。假设每个资源加载耗时不同。</p>
        
        <div class="legend">
            <div class="legend-item"><div class="dot" style="background: #e9ecef"></div>等待排队</div>
            <div class="legend-item"><div class="dot" style="background: #4caf50"></div>传输中</div>
            <div class="legend-item"><div class="dot" style="background: #2196f3"></div>完成</div>
        </div>

        <div class="controls">
            <button id="startBtn" onclick="startDemo()">开始加载对比</button>
        </div>

        <div class="demo-area">
            <!-- HTTP/1.1 演示 -->
            <div class="protocol-demo">
                <div class="protocol-title">HTTP/1.1 (限制 6 并发)</div>
                <div id="container-h1" class="connection-pool"></div>
            </div>

            <!-- HTTP/2 演示 -->
            <div class="protocol-demo">
                <div class="protocol-title">HTTP/2 (多路复用)</div>
                <div id="container-h2" class="connection-pool"></div>
            </div>
        </div>
    </div>

    <script>
        const REQUEST_COUNT = 30;
        const MAX_CONCURRENT_H1 = 6; // HTTP/1.1 限制并发数
        
        // 生成随机加载时间 (3s - 6s)
        function getRandomDuration() {
            return Math.random() * 3000 + 3000;
        }

        class RequestSimulator {
            constructor(id, containerId, type) {
                this.id = id;
                this.container = document.getElementById(containerId);
                this.type = type; // 'h1' or 'h2'
                this.items = [];
                this.queue = [];
                this.activeCount = 0;
                this.createElements();
            }

            createElements() {
                this.container.innerHTML = '';
                this.items = [];
                for (let i = 0; i < REQUEST_COUNT; i++) {
                    const el = document.createElement('div');
                    el.className = 'request-item';
                    el.innerHTML = `<div class="progress-bar" id="${this.type}-bar-${i}"></div><span style="position:relative;z-index:1">Req ${i+1}</span>`;
                    this.container.appendChild(el);
                    
                    this.items.push({
                        id: i,
                        el: el,
                        bar: el.querySelector('.progress-bar'),
                        duration: 0,
                        progress: 0,
                        status: 'waiting'
                    });
                }
            }

            setDurations(durations) {
                this.items.forEach((item, index) => {
                    item.duration = durations[index];
                });
            }

            start() {
                // 重置状态
                this.items.forEach(item => {
                    item.progress = 0;
                    item.status = 'waiting';
                    item.bar.style.width = '0%';
                    item.el.classList.remove('finished', 'running');
                });
                this.activeCount = 0;
                this.queue = [...this.items];
                
                this.processQueue();
            }

            processQueue() {
                if (this.queue.length === 0 && this.activeCount === 0) return;

                // HTTP/1.1 限制并发，HTTP/2 几乎无限制（这里模拟全并发）
                const limit = this.type === 'h1' ? MAX_CONCURRENT_H1 : REQUEST_COUNT;

                while (this.activeCount < limit && this.queue.length > 0) {
                    const item = this.queue.shift();
                    this.runRequest(item);
                }
            }

            runRequest(item) {
                this.activeCount++;
                item.status = 'running';
                item.el.classList.add('running');
                
                const startTime = performance.now();
                
                const animate = (currentTime) => {
                    const elapsed = currentTime - startTime;
                    let percent = (elapsed / item.duration) * 100;

                    if (percent >= 100) {
                        percent = 100;
                        item.status = 'finished';
                        item.el.classList.remove('running');
                        item.el.classList.add('finished');
                        this.activeCount--;
                        this.processQueue(); // 一个完成了，尝试调度下一个
                    } else {
                        requestAnimationFrame(animate);
                    }
                    
                    item.bar.style.width = `${percent}%`;
                };

                requestAnimationFrame(animate);
            }
        }

        let h1Sim, h2Sim;

        function initDemo() {
            h1Sim = new RequestSimulator(1, 'container-h1', 'h1');
            h2Sim = new RequestSimulator(2, 'container-h2', 'h2');
            
            // 初始化一次随机时间，让界面看起来正常
            const durations = Array.from({length: REQUEST_COUNT}, () => getRandomDuration());
            h1Sim.setDurations(durations);
            h2Sim.setDurations(durations);
        }

        function startDemo() {
            const btn = document.getElementById('startBtn');
            btn.disabled = true;
            
            // 生成新的随机时间
            const durations = Array.from({length: REQUEST_COUNT}, () => getRandomDuration());
            
            // 同步设置时间
            h1Sim.setDurations(durations);
            h2Sim.setDurations(durations);

            // 同时开始
            h1Sim.start();
            h2Sim.start();

            // 简单粗暴的重置按钮逻辑，实际应该监听所有完成
            setTimeout(() => {
                btn.disabled = false;
                btn.innerText = "重新开始";
            }, 25000); // 估算时间
        }

        // 初始化
        initDemo();

    </script>
</body>
</html>
