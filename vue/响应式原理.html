<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vue 2 vs Vue 3 响应式原理可视化</title>
    <style>
      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        line-height: 1.6;
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
        background-color: #f5f7fa;
        color: #333;
      }
      h1 {
        text-align: center;
        color: #42b983;
        margin-bottom: 40px;
      }
      h2 {
        color: #35495e;
        border-bottom: 2px solid #42b983;
        padding-bottom: 10px;
        margin-top: 40px;
      }
      .container {
        display: flex;
        flex-direction: column;
        gap: 40px;
      }
      .section {
        background: white;
        padding: 30px;
        border-radius: 12px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }
      .diagram-container {
        display: flex;
        justify-content: center;
        margin: 20px 0;
        background-color: #fff;
      }
      .explanation {
        background-color: #f8f9fa;
        padding: 20px;
        border-radius: 8px;
        border-left: 5px solid #42b983;
      }
      .key-concepts {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 20px;
        margin-top: 20px;
      }
      .concept-card {
        background: #fff;
        border: 1px solid #e0e0e0;
        padding: 15px;
        border-radius: 8px;
      }
      .concept-title {
        font-weight: bold;
        color: #42b983;
        margin-bottom: 10px;
        display: block;
      }
      code {
        background-color: #eee;
        padding: 2px 5px;
        border-radius: 4px;
        font-family: Consolas, monospace;
        color: #e96900;
      }
      
      /* 放大功能样式 */
      .diagram-container {
        cursor: zoom-in;
        transition: all 0.3s ease;
        border: 1px solid transparent;
      }
      .diagram-container:hover {
        border-color: #42b983;
        box-shadow: 0 0 10px rgba(66, 185, 131, 0.2);
      }
      
      .modal {
        display: none;
        position: fixed;
        z-index: 1000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        overflow: auto;
        background-color: rgba(0,0,0,0.8);
        backdrop-filter: blur(5px);
        justify-content: center;
        align-items: center;
        animation: fadeIn 0.3s;
      }
      
      .modal-content {
        background-color: #fff;
        margin: auto;
        padding: 20px;
        border-radius: 8px;
        width: 95%;
        height: 90%;
        display: flex;
        justify-content: center;
        align-items: center;
        position: relative;
        overflow: auto;
      }
      
      .modal-content svg {
        width: 100% !important;
        height: 100% !important;
        max-width: none !important;
      }

      .close {
        position: absolute;
        top: 20px;
        right: 30px;
        color: #fff;
        font-size: 40px;
        font-weight: bold;
        cursor: pointer;
        z-index: 1001;
        text-shadow: 0 0 5px rgba(0,0,0,0.5);
      }
      
      .close:hover {
        color: #42b983;
      }

      @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
      }
    </style>
  </head>
  <body>
    <h1>Vue 响应式原理对比 (Vue 2 vs Vue 3)</h1>

    <div class="container">
      <!-- Vue 2 Section -->
      <div class="section">
        <h2>Vue 2 响应式原理 (Object.defineProperty)</h2>

        <div class="explanation">
          <p>
            Vue 2 使用 <code>Object.defineProperty</code> 对数据进行劫持。核心是
            <strong>Observer</strong>、<strong>Dep</strong> 和
            <strong>Watcher</strong>。
          </p>
        </div>

        <div class="diagram-container">
          <pre class="mermaid">
graph TD
    subgraph "初始化阶段 (Init)"
        Data("原始 Data") -->|new Observer| Observer["Observer 类"]
        Observer -->|Object.defineProperty| GetterSetter{"Getter / Setter"}
        
        Compile("模板编译") -->|解析指令/插值| Watcher["Watcher 观察者"]
        Watcher -->|读取数据触发 Getter| GetterSetter
    end

    subgraph "依赖收集 (Dependency Collection)"
        GetterSetter -->|"Getter: dep.depend()"| Dep["Dep 依赖收集器"]
        Dep -->|addSub| WatcherList("Watcher 列表")
        WatcherList -.->|包含| Watcher
    end

    subgraph "派发更新 (Notify Update)"
        UserAction("用户修改数据") -->|触发 Setter| GetterSetter
        GetterSetter -->|"Setter: dep.notify()"| Dep
        Dep -->|遍历 notify| Watcher
        Watcher -->|update| CB("回调函数/视图更新")
        CB -->|patch| DOM("真实 DOM")
    end

    style Observer fill:#e1f5fe,stroke:#01579b
    style Dep fill:#fff9c4,stroke:#fbc02d
    style Watcher fill:#e8f5e9,stroke:#2e7d32
    style GetterSetter fill:#f3e5f5,stroke:#7b1fa2
                </pre
          >
        </div>

        <div class="key-concepts">
          <div class="concept-card">
            <span class="concept-title">Observer (观察者)</span>
            负责将数据对象的所有属性转换为
            getter/setter，实现数据劫持。递归遍历对象，深度监听。
          </div>
          <div class="concept-card">
            <span class="concept-title">Dep (依赖收集器)</span>
            每个响应式属性都有一个对应的 Dep
            实例。它负责收集依赖（Watcher）并在数据变化时通知它们。
          </div>
          <div class="concept-card">
            <span class="concept-title">Watcher (订阅者)</span>
            代表一个依赖（如组件渲染函数、computed、watch）。当数据变化时，Dep
            通知 Watcher，Watcher 执行回调更新视图。
          </div>
        </div>
      </div>

      <!-- Vue 3 Section -->
      <div class="section">
        <h2>Vue 3 响应式原理 (Proxy)</h2>

        <div class="explanation">
          <p>
            Vue 3 使用 ES6 的 <code>Proxy</code> 进行代理，配合
            <code>Reflect</code> 操作对象。核心是
            <strong>reactive (Proxy)</strong>、<strong>effect (副作用)</strong>
            和 <strong>track/trigger (依赖管理)</strong>。
          </p>
        </div>

        <div class="diagram-container">
          <pre class="mermaid">
graph TD
    subgraph "创建响应式对象"
        RawData("原始 Data") -->|reactive| ProxyObj["Proxy 代理对象"]
        ProxyObj -->|"Handler: get"| TrackOp("track 依赖收集")
        ProxyObj -->|"Handler: set"| TriggerOp("trigger 派发更新")
    end

    subgraph "副作用执行 & 依赖收集"
        EffectFn("effect 副作用函数") -->|执行| ProxyObj
        ProxyObj -->|读取属性| TrackOp
        TrackOp -->|查找/创建| TargetMap["targetMap (WeakMap)"]
        TargetMap -->|target| DepsMap["depsMap (Map)"]
        DepsMap -->|key| DepSet["Dep (Set of Effect)"]
        DepSet -->|add| EffectFn
    end

    subgraph "触发更新"
        UserMod("修改数据") -->|设置属性| ProxyObj
        ProxyObj -->|触发| TriggerOp
        TriggerOp -->|查找| TargetMap
        TargetMap -->|获取| DepSet
        DepSet -->|遍历执行| EffectFn
        EffectFn -->|重新执行| UpdateView("更新视图")
    end

    style ProxyObj fill:#e1f5fe,stroke:#01579b
    style TargetMap fill:#fff9c4,stroke:#fbc02d
    style EffectFn fill:#e8f5e9,stroke:#2e7d32
    style TrackOp fill:#f3e5f5,stroke:#7b1fa2
    style TriggerOp fill:#f3e5f5,stroke:#7b1fa2
                </pre
          >
        </div>

        <div class="key-concepts">
          <div class="concept-card">
            <span class="concept-title">Reactive (Proxy)</span>
            使用 Proxy 代理整个对象，拦截 get、set、deleteProperty
            等操作。无需递归初始化，懒代理。
          </div>
          <div class="concept-card">
            <span class="concept-title">Effect (副作用)</span>
            响应式系统中的执行单元（类似 Vue 2 的
            Watcher）。当依赖的数据变化时，effect 会重新执行。
          </div>
          <div class="concept-card">
            <span class="concept-title">Track & Trigger</span>
            <strong>track</strong>: 在 get 中收集当前活跃的 effect。<br />
            <strong>trigger</strong>: 在 set 中查找并执行相关的 effects。<br />
            依赖关系存储在全局的
            <code
              >WeakMap&lt;target, Map&lt;key, Set&lt;effect&gt;&gt;&gt;</code
            >
            中。
          </div>
        </div>
      </div>
    </div>

    <!-- 模态框 -->
    <div id="imageModal" class="modal">
        <span class="close">&times;</span>
        <div class="modal-content" id="modalImage"></div>
    </div>

    <!-- 引入 Mermaid -->
    <script type="module">
      import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";
      
      mermaid.initialize({
        startOnLoad: true,
        theme: "neutral",
        flowchart: {
          curve: "basis",
          useMaxWidth: false, // 允许图表超出容器宽度，配合缩放更清晰
          htmlLabels: true
        },
      });

      // 简单的模态框逻辑
      const modal = document.getElementById("imageModal");
      const modalImg = document.getElementById("modalImage");
      const closeBtn = document.getElementsByClassName("close")[0];

      // 监听点击事件（事件委托，因为 mermaid 是异步渲染的）
      document.addEventListener('click', function(e) {
        // 查找点击目标是否在 diagram-container 内的 svg 中
        const container = e.target.closest('.diagram-container');
        if (container) {
            const svg = container.querySelector('svg');
            if (svg) {
                modal.style.display = "flex";
                modalImg.innerHTML = ''; // 清空
                
                // 克隆 SVG
                const clone = svg.cloneNode(true);
                // 移除可能限制大小的属性
                clone.removeAttribute('style');
                clone.removeAttribute('width');
                clone.removeAttribute('height');
                clone.style.width = '100%';
                clone.style.height = 'auto';
                
                modalImg.appendChild(clone);
                document.body.style.overflow = 'hidden'; // 禁止背景滚动
            }
        }
      });

      // 关闭模态框
      closeBtn.onclick = function() {
        modal.style.display = "none";
        document.body.style.overflow = 'auto';
      }

      // 点击模态框背景关闭
      modal.onclick = function(e) {
        if (e.target === modal) {
            modal.style.display = "none";
            document.body.style.overflow = 'auto';
        }
      }
      
      // ESC 关闭
      document.addEventListener('keydown', function(e) {
        if (e.key === "Escape" && modal.style.display === "flex") {
            modal.style.display = "none";
            document.body.style.overflow = 'auto';
        }
      });
    </script>
  </body>
</html>
